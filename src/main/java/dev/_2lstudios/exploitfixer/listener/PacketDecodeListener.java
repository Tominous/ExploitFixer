package dev._2lstudios.exploitfixer.listener;

import java.nio.charset.Charset;
import java.util.regex.Pattern;

import org.bukkit.entity.Player;
import org.bukkit.event.Cancellable;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;

import dev._2lstudios.exploitfixer.managers.ModuleManager;
import dev._2lstudios.exploitfixer.modules.PacketsModule;
import dev._2lstudios.exploitfixer.utils.ExploitUtil;
import dev._2lstudios.exploitfixer.utils.ProtocolUtil;
import dev._2lstudios.hamsterapi.events.PacketDecodeEvent;
import dev._2lstudios.hamsterapi.hamsterplayer.HamsterPlayer;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.EmptyByteBuf;

public class PacketDecodeListener implements Listener {
    private static String PREFIX = "[Decoder|Data] ";
    private static String PREFIX_OFFLINE = "[Decoder|Offline] ";

    // Pattern for detecting an amount of tags used
    private Pattern tagPattern;

    private ExploitUtil exploitUtil;
    private PacketsModule packetsModule;

    PacketDecodeListener(ExploitUtil exploitUtil, ModuleManager moduleManager) {
        this.exploitUtil = exploitUtil;
        this.packetsModule = moduleManager.getPacketsModule();
        this.tagPattern = Pattern.compile("(.)[{]{" + packetsModule.getDataMaxFlags() + ",}(.)");
    }

    private String getName(Player player) {
        if (player == null) {
            return "unknown";
        }
        return player.getName();
    }

    private void onPacketDecode(Cancellable event, HamsterPlayer hamsterPlayer, Player player,
            ByteBuf byteBuf) {
        if (player != null && player.isOnline()) {
            String bypassPermission = packetsModule.getBypassPermission();

            if (bypassPermission != null && player.hasPermission(bypassPermission)) {
                return;
            }

            String playerName = player.getName();
            double dataVls = packetsModule.getDataVls();
            double dataVlMultiplier = packetsModule.getDataVlMultiplier();
            int dataBytes = packetsModule.getDataMaxSize();
            int refCnt = byteBuf.refCnt();
            int capacity = byteBuf.capacity();

            if (capacity < 0) {
                String reason = PREFIX + playerName
                        + " sent a packet with invalid capacity! capacity: " + capacity + " Vls: " + dataVls;

                exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls, "Bad Capacity");
            } else if (refCnt < 1) {
                String reason = PREFIX + playerName + " sent a packet with invalid refCnt! refCnt: "
                        + refCnt + " Vls: " + dataVls;

                exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls, "Bad Reference Count");
            } else {
                int readableBytes = byteBuf.readableBytes();
                String reason = null;

                if (capacity > dataBytes) {
                    reason = PREFIX + playerName + " sent a packet that exceeds capacity bytes limit! " + capacity
                            + "/" + dataBytes + " Vls: " + dataVls;
                } else if (readableBytes > dataBytes) {
                    reason = PREFIX + playerName + " sent a packet that exceeds readable bytes limit! " + readableBytes
                            + "/" + dataBytes + " Vls: " + dataVls;
                } else {
                    if (!(byteBuf instanceof EmptyByteBuf)) {
                        int oldReaderIndex = byteBuf.readerIndex();
                        int packetId = ProtocolUtil.readVarInt(byteBuf);

                        byteBuf.readerIndex(oldReaderIndex);

                        if (packetId == 18) {
                            return;
                        } else {
                            // Check if it's a edit book packet
                            String content = byteBuf.toString(Charset.defaultCharset());

                            byteBuf.readerIndex(oldReaderIndex);

                            if (packetsModule.getDataMaxFlags() > 0 && tagPattern.matcher(content).find()) {
                                reason = PREFIX + playerName
                                        + " sent a packet with too many tags! Vls: " + dataVls;

                                exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls, "Many Tags");
                            }
                        }
                    }

                    if (dataVlMultiplier > 0) {
                        exploitUtil.addVls(event, hamsterPlayer, player, capacity * dataVlMultiplier, "Too Much Data");
                    }

                    return;
                }

                exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, dataVls, "Too Big Packet");
            }
        } else if (packetsModule.isOffline()) {
            String reason = PREFIX_OFFLINE + getName(player) + " sent a packet while being offline!";

            exploitUtil.cancelExploit(event, hamsterPlayer, player, reason, 0, "Offline");
        }
    }

    @EventHandler(ignoreCancelled = true, priority = EventPriority.LOWEST)
    public void onPacketDecode(PacketDecodeEvent event) {
        if (!packetsModule.isEnabled()) {
            return;
        }

        HamsterPlayer hamsterPlayer = event.getHamsterPlayer();
        ByteBuf byteBuf = event.getByteBuf().get();

        onPacketDecode(event, hamsterPlayer, hamsterPlayer.getPlayer(), byteBuf);
    }
}
